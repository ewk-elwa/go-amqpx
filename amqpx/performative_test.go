package amqpx

import (
	"fmt"
	"testing"
)

func TestReadProtocolHeader(t *testing.T) {
	goodBuffer := []byte{0x41, 0x4d, 0x51, 0x50, 0x00, 0x01, 0x00, 0x00}
	protocolVersion, bytesUsed, err := ParseProtocolHeader(goodBuffer)

	if err != nil || bytesUsed != 8 {

	}
	displayJsonStruct(protocolVersion)

}

func TestReadOpenFraming(t *testing.T) {
	openFrame := []byte{
		0x00, 0x00, 0x00, 0x52, 0x02, 0x00, 0x00, 0x00, 0x00, 0x53, 0x10, 0xd0, 0x00, 0x00, 0x00, 0x42,
		0x00, 0x00, 0x00, 0x0a, 0xa1, 0x24, 0x63, 0x62, 0x64, 0x35, 0x65, 0x36, 0x33, 0x63, 0x2d, 0x33,
		0x66, 0x34, 0x34, 0x2d, 0x34, 0x39, 0x32, 0x66, 0x2d, 0x38, 0x30, 0x37, 0x62, 0x2d, 0x65, 0x37,
		0x35, 0x33, 0x36, 0x64, 0x39, 0x64, 0x62, 0x35, 0x30, 0x65, 0xa1, 0x08, 0x74, 0x65, 0x73, 0x74,
		0x68, 0x6f, 0x73, 0x74, 0x40, 0x60, 0x7f, 0xff, 0x70, 0x00, 0x00, 0x75, 0x30, 0x40, 0x40, 0x40,
		0x40, 0x40}
	frame, bytesUsed, performative, err := ParseFraming(openFrame)

	if err != nil || (bytesUsed-3) != (uint32(frame.Doff)*4) {
		t.Errorf("We have a problem with framing: Doff*4:%d not equal bytesUsed:%d", frame.Doff*4, bytesUsed)
	}

	displayJsonStruct(frame)

	if performative == PerfOpen {
		connParameters, _, err := ParsePerformativeOpen(openFrame[bytesUsed:])
		if err != nil {
			t.Errorf("%s\nReadOpenPerformative was incorrect, expected no errors", err.Error())
		} else {
			displayJsonStruct(connParameters)
		}
	}
}

func TestReadBeginFraming(t *testing.T) {

	beginFrame := []byte{
		0x00, 0x00, 0x00, 0x21, 0x02, 0x00, 0x00, 0x00, 0x00, 0x53, 0x11, 0xd0, 0x00, 0x00, 0x00, 0x11,
		0x00, 0x00, 0x00, 0x04, 0x40, 0x52, 0x00, 0x70, 0x7f, 0xff, 0xff, 0xff, 0x70, 0x7f, 0xff, 0xff,
		0xff}

	frame, bytesUsed, performative, err := ParseFraming(beginFrame)

	if err != nil || (bytesUsed-3) != (uint32(frame.Doff)*4) {
		t.Errorf("We have a problem with framing: Doff*4:%d not equal bytesUsed:%d", frame.Doff*4, bytesUsed)
	}

	displayJsonStruct(frame)

	if performative == PerfBegin {
		sessionParameters, _, err := ParsePerformativeBegin(beginFrame[bytesUsed:])
		if err != nil {
			t.Errorf("%s\nReadBeginPerformative was incorrect, expected no errors", err.Error())
		} else {
			displayJsonStruct(sessionParameters)
		}
	}
}

func TestReadOpenPerformative(t *testing.T) {
	valConstructor := []byte{0xd0}
	valBuf := []byte{0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x0a, 0xa1, 0x24, 0x63, 0x62, 0x64, 0x35, 0x65, 0x36, 0x33, 0x63, 0x2d, 0x33, 0x66, 0x34, 0x34, 0x2d, 0x34, 0x39, 0x32, 0x66, 0x2d, 0x38, 0x30, 0x37, 0x62, 0x2d, 0x65, 0x37, 0x35, 0x33, 0x36, 0x64, 0x39, 0x64, 0x62, 0x35, 0x30, 0x65, 0xa1, 0x08, 0x74, 0x65, 0x73, 0x74, 0x68, 0x6f, 0x73, 0x74, 0x40, 0x60, 0x7f, 0xff, 0x70, 0x00, 0x00, 0x75, 0x30, 0x40, 0x40, 0x40, 0x40, 0x40}
	goodBuffer := append(valConstructor, valBuf...)

	connParameters, _, err := ParsePerformativeOpen(goodBuffer)
	if err != nil {
		t.Errorf("%s\nReadOpenPerformative was incorrect, expected no errors", err.Error())
	} else {
		displayJsonStruct(connParameters)
	}
}

func TestReadAttach(t *testing.T) {
	goodBuffer := []byte{
		0xd0, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x0b, 0xa1, 0x24, 0x63, 0x39, 0x66, 0x32, 0x36,
		0x39, 0x37, 0x38, 0x2d, 0x34, 0x37, 0x34, 0x34, 0x2d, 0x34, 0x31, 0x35, 0x30, 0x2d, 0x39, 0x34,
		0x31, 0x35, 0x2d, 0x37, 0x32, 0x31, 0x38, 0x39, 0x31, 0x32, 0x62, 0x39, 0x66, 0x30, 0x37, 0x52,
		0x00, 0x41, 0x50, 0x02, 0x50, 0x00, 0x00, 0x53, 0x28, 0xd0, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
		0x00, 0x0b, 0x40, 0x52, 0x00, 0x40, 0x52, 0x00, 0x42, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,
		0x53, 0x29, 0xd0, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x07, 0xa1, 0x11, 0x31, 0x30, 0x2e,
		0x34, 0x2e, 0x32, 0x39, 0x2e, 0x32, 0x32, 0x37, 0x3a, 0x34, 0x34, 0x38, 0x37, 0x38, 0x52, 0x00,
		0x40, 0x52, 0x00, 0x42, 0x40, 0x40, 0x40, 0x40, 0x52, 0x00, 0x53, 0x00}

	bytesUsed := uint32(0)
	attach, bytesUsed, err := ParsePerformativeAttach(goodBuffer[bytesUsed:])
	if err != nil {
		t.Errorf("%s\nReadAttachPerformative was incorrect, expected no errors", err.Error())
	} else {
		displayJsonStruct(attach)
	}
}

func TestReadFlowPerformative(t *testing.T) {
	goodBuffer := []byte{
		0xd0, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x09, 0x40, 0x70, 0x7f, 0xff, 0xff, 0xff, 0x52,
		0x00, 0x70, 0x7f, 0xff, 0xff, 0xff, 0x52, 0x01, 0x52, 0x00, 0x52, 0xc8, 0x40, 0x42}

	bytesUsed := uint32(0)
	flow, bytesUsed, err := ParsePerformativeFlow(goodBuffer[bytesUsed:])
	if err != nil {
		t.Errorf("%s\nReadFlowPerformative was incorrect, expected no errors", err.Error())
	} else {

		displayJsonStruct(flow)
	}
}

func TestReadTransferPerformative(t *testing.T) {
	argumentBuffer := []byte{
		0xd0, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x08, 0x52, 0x11, 0x52, 0x22, 0xa0, 0x08, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x42, 0x42, 0x40, 0x40}

	bytesUsed := uint32(0)
	transfer, bytesUsed, err := ParsePerformativeTransfer(argumentBuffer[bytesUsed:])
	if err != nil {
		t.Errorf("%s\nReadTransferPerformative was incorrect, expected no errors", err.Error())
	} else {
		displayJsonStruct(transfer)
	}
}

func TestReadDispositionPerformative(t *testing.T) {
	//buffer := []byte{
	//	0x00, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x00, 0x00, 0x53, 0x15, 0xd0, 0x00, 0x00, 0x00, 0x16,
	//	0x00, 0x00, 0x00, 0x05, 0x41, 0x52, 0x00, 0x52, 0x00, 0x41, 0x00, 0x53, 0x24, 0xd0, 0x00, 0x00,
	//	0x00, 0x04, 0x00, 0x00, 0x00, 0x00}
	buffer := []byte{0xd0, 0x00, 0x00, 0x00,
		0x0e, 0x00, 0x00, 0x00, 0x05, 0x41, 0x52, 0x00, 0x52, 0x09, 0x41, 0x00, 0x53, 0x24, 0x45}
	//buffer := []byte{
	//	0xd0, 0x00, 0x00, 0x00, 0x16,
	//	0x00, 0x00, 0x00, 0x05, 0x41, 0x52, 0x00, 0x52, 0x00, 0x41, 0x00, 0x53, 0x24, 0xd0, 0x00, 0x00,
	//	0x00, 0x04, 0x00, 0x00, 0x00, 0x00}
	bytesUsed := uint32(0)
	disposition, bytesUsed, err := ParsePerformativeDisposition(buffer[bytesUsed:])
	if err != nil {
		t.Errorf("%s\nReadDispositionPerformative was incorrect, expected no errors", err.Error())
	} else {
		displayJsonStruct(disposition)
	}
}

func TestReadTransferFraming(t *testing.T) {
	frameInx := uint32(0)
	transferFrame := []byte{
		0x00, 0x00, 0x00, 0x7d, 0x02, 0x00, 0x00, 0x00, 0x00, 0x53, 0x14, 0xd0, 0x00, 0x00, 0x00, 0x18,
		0x00, 0x00, 0x00, 0x08, 0x52, 0x01, 0x52, 0x00, 0xa0, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x52, 0x00, 0x42, 0x42, 0x40, 0x40, 0x00, 0x53, 0x70, 0xd0, 0x00, 0x00, 0x00, 0x0b,
		0x00, 0x00, 0x00, 0x05, 0x42, 0x50, 0x04, 0x40, 0x42, 0x52, 0x00, 0x00, 0x53, 0x73, 0xd0, 0x00,
		0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x0d, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x83,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x40, 0x52, 0x00, 0x40, 0x00, 0x53, 0x77, 0xa0, 0x13, 0x53, 0x02, 0x00, 0x01, 0x18, 0x05,
		0x62, 0x2e, 0x4b, 0x43, 0x53, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x93, 0x1b, 0x64}
	frame, bytesUsed, performative, err := ParseFraming(transferFrame)
	frameInx += bytesUsed

	if err != nil || (bytesUsed-3) != (uint32(frame.Doff)*4) {
		t.Errorf("We have a problem with framing: Doff*4:%d not equal bytesUsed:%d", frame.Doff*4, bytesUsed)
	}
	displayJsonStruct(frame)

	if performative == PerfTransfer {
		transfer, bytesUsed, err := ParsePerformativeTransfer(transferFrame[frameInx:])
		if err != nil {
			t.Errorf("%s\nReadTransferPerformative was incorrect, expected no errors", err.Error())
		} else {
			displayJsonStruct(transfer)
			frameInx += bytesUsed
		}

		performative, used, _ := ParseBlockType(transferFrame[frameInx:])
		frameInx += used
		if performative != PerfHeader {
			t.Errorf("%s\nExpected message header, got:", fmt.Sprintf("0x%x", performative))
		} else {
			header, bytesUsed, err := ParseMessageHeader(transferFrame[frameInx:])
			if err != nil {
				t.Errorf("%s\nReadMessageHeader was incorrect, expected no errors", err.Error())
			} else {
				displayJsonStruct(header)
			}
			frameInx += bytesUsed

			performative, used, _ := ParseBlockType(transferFrame[frameInx:])
			frameInx += used
			if performative != PerfProperties {
				t.Errorf("%s\nExpected message header, got:", fmt.Sprintf("0x%x", performative))
			} else {
				properties, bytesUsed, err := ParseMessageProperties(transferFrame[frameInx:])
				if err != nil {
					t.Errorf("%s\nReadMessageProperties was incorrect, expected no errors", err.Error())
				} else {
					displayJsonStruct(properties)
				}
				frameInx += bytesUsed

				performative, used, _ := ParseBlockType(transferFrame[frameInx:])
				frameInx += used
				if performative != PerfAmqpValue {
					t.Errorf("%s\nExpected message header, got:", fmt.Sprintf("0x%x", performative))
				} else {
					amqpValue, _, err := ParseMessageAmqpValue(transferFrame[frameInx:])
					if err != nil {
						t.Errorf("%s\nReadMessageAmqpValue was incorrect, expected no errors", err.Error())
					} else {
						displayJsonStruct(amqpValue)
					}
				}
			}
		}
	}
}
